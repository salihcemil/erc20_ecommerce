{"ast":null,"code":"/**\n * compress/decompress hex-strings to utf16 or base64\n * thx @juvian\n * @link https://stackoverflow.com/a/40471908/3443137\n */\nimport { removeLeading0x, addLeading0x } from './util';\nexport function compress(hex) {\n  var base64 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  hex = removeLeading0x(hex); // if base64:true, we use our own function because it results in a smaller output\n\n  if (base64 === true) return Buffer.from(hex, 'hex').toString('base64');\n  var string = '';\n\n  while (hex.length % 4 != 0) {\n    // we need it to be multiple of 4\n    hex = '0' + hex;\n  }\n\n  for (var i = 0; i < hex.length; i += 4) {\n    // get char from ascii code which goes from 0 to 65536\n    string += String.fromCharCode(parseInt(hex.substring(i, i + 4), 16));\n  }\n\n  return string;\n}\nexport function decompress(compressedString) {\n  var base64 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; // if base64:true, we use our own function because it results in a smaller output\n\n  if (base64 === true) {\n    var ret = Buffer.from(compressedString, 'base64').toString('hex');\n    return addLeading0x(ret);\n  }\n\n  var hex = '';\n\n  for (var i = 0; i < compressedString.length; i++) {\n    // get character ascii code and convert to hexa string, adding necessary 0s\n    hex += ((i == 0 ? '' : '000') + compressedString.charCodeAt(i).toString(16)).slice(-4);\n  }\n\n  hex = hex.toLowerCase();\n  return addLeading0x(hex);\n}","map":{"version":3,"sources":["/Users/salihcemil/Desktop/projects/ecommerce/node_modules/eth-crypto/dist/es/hex.js"],"names":["removeLeading0x","addLeading0x","compress","hex","base64","arguments","length","undefined","Buffer","from","toString","string","i","String","fromCharCode","parseInt","substring","decompress","compressedString","ret","charCodeAt","slice","toLowerCase"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,SAASA,eAAT,EAA0BC,YAA1B,QAA8C,QAA9C;AACA,OAAO,SAASC,QAAT,CAAkBC,GAAlB,EAAuB;AAC5B,MAAIC,MAAM,GAAGC,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBE,SAAzC,GAAqDF,SAAS,CAAC,CAAD,CAA9D,GAAoE,KAAjF;AACAF,EAAAA,GAAG,GAAGH,eAAe,CAACG,GAAD,CAArB,CAF4B,CAEA;;AAE5B,MAAIC,MAAM,KAAK,IAAf,EAAqB,OAAOI,MAAM,CAACC,IAAP,CAAYN,GAAZ,EAAiB,KAAjB,EAAwBO,QAAxB,CAAiC,QAAjC,CAAP;AACrB,MAAIC,MAAM,GAAG,EAAb;;AAEA,SAAOR,GAAG,CAACG,MAAJ,GAAa,CAAb,IAAkB,CAAzB,EAA4B;AAC1B;AACAH,IAAAA,GAAG,GAAG,MAAMA,GAAZ;AACD;;AAED,OAAK,IAAIS,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGT,GAAG,CAACG,MAAxB,EAAgCM,CAAC,IAAI,CAArC,EAAwC;AACtC;AACAD,IAAAA,MAAM,IAAIE,MAAM,CAACC,YAAP,CAAoBC,QAAQ,CAACZ,GAAG,CAACa,SAAJ,CAAcJ,CAAd,EAAiBA,CAAC,GAAG,CAArB,CAAD,EAA0B,EAA1B,CAA5B,CAAV;AACD;;AAED,SAAOD,MAAP;AACD;AACD,OAAO,SAASM,UAAT,CAAoBC,gBAApB,EAAsC;AAC3C,MAAId,MAAM,GAAGC,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBE,SAAzC,GAAqDF,SAAS,CAAC,CAAD,CAA9D,GAAoE,KAAjF,CAD2C,CAG3C;;AACA,MAAID,MAAM,KAAK,IAAf,EAAqB;AACnB,QAAIe,GAAG,GAAGX,MAAM,CAACC,IAAP,CAAYS,gBAAZ,EAA8B,QAA9B,EAAwCR,QAAxC,CAAiD,KAAjD,CAAV;AACA,WAAOT,YAAY,CAACkB,GAAD,CAAnB;AACD;;AAED,MAAIhB,GAAG,GAAG,EAAV;;AAEA,OAAK,IAAIS,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGM,gBAAgB,CAACZ,MAArC,EAA6CM,CAAC,EAA9C,EAAkD;AAChD;AACAT,IAAAA,GAAG,IAAI,CAAC,CAACS,CAAC,IAAI,CAAL,GAAS,EAAT,GAAc,KAAf,IAAwBM,gBAAgB,CAACE,UAAjB,CAA4BR,CAA5B,EAA+BF,QAA/B,CAAwC,EAAxC,CAAzB,EAAsEW,KAAtE,CAA4E,CAAC,CAA7E,CAAP;AACD;;AAEDlB,EAAAA,GAAG,GAAGA,GAAG,CAACmB,WAAJ,EAAN;AACA,SAAOrB,YAAY,CAACE,GAAD,CAAnB;AACD","sourcesContent":["/**\n * compress/decompress hex-strings to utf16 or base64\n * thx @juvian\n * @link https://stackoverflow.com/a/40471908/3443137\n */\nimport { removeLeading0x, addLeading0x } from './util';\nexport function compress(hex) {\n  var base64 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  hex = removeLeading0x(hex); // if base64:true, we use our own function because it results in a smaller output\n\n  if (base64 === true) return Buffer.from(hex, 'hex').toString('base64');\n  var string = '';\n\n  while (hex.length % 4 != 0) {\n    // we need it to be multiple of 4\n    hex = '0' + hex;\n  }\n\n  for (var i = 0; i < hex.length; i += 4) {\n    // get char from ascii code which goes from 0 to 65536\n    string += String.fromCharCode(parseInt(hex.substring(i, i + 4), 16));\n  }\n\n  return string;\n}\nexport function decompress(compressedString) {\n  var base64 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  // if base64:true, we use our own function because it results in a smaller output\n  if (base64 === true) {\n    var ret = Buffer.from(compressedString, 'base64').toString('hex');\n    return addLeading0x(ret);\n  }\n\n  var hex = '';\n\n  for (var i = 0; i < compressedString.length; i++) {\n    // get character ascii code and convert to hexa string, adding necessary 0s\n    hex += ((i == 0 ? '' : '000') + compressedString.charCodeAt(i).toString(16)).slice(-4);\n  }\n\n  hex = hex.toLowerCase();\n  return addLeading0x(hex);\n}"]},"metadata":{},"sourceType":"module"}