{"ast":null,"code":"import { utils as ethersUtils, Wallet } from 'ethers';\nimport { stripHexPrefix } from 'ethereumjs-util';\nvar MIN_ENTROPY_SIZE = 128;\nvar keccak256 = ethersUtils.keccak256;\n/**\n * create a privateKey from the given entropy or a new one\n * @param  {Buffer} entropy\n * @return {string}\n */\n\nexport function createPrivateKey(entropy) {\n  if (entropy) {\n    if (!Buffer.isBuffer(entropy)) throw new Error('EthCrypto.createPrivateKey(): given entropy is no Buffer');\n    if (Buffer.byteLength(entropy, 'utf8') < MIN_ENTROPY_SIZE) throw new Error('EthCrypto.createPrivateKey(): Entropy-size must be at least ' + MIN_ENTROPY_SIZE);\n    var outerHex = keccak256(entropy);\n    return outerHex;\n  } else {\n    var innerHex = keccak256(ethersUtils.concat([ethersUtils.randomBytes(32), ethersUtils.randomBytes(32)]));\n    var middleHex = ethersUtils.concat([ethersUtils.concat([ethersUtils.randomBytes(32), innerHex]), ethersUtils.randomBytes(32)]);\n\n    var _outerHex = keccak256(middleHex);\n\n    return _outerHex;\n  }\n}\n/**\n * creates a new object with\n * private-, public-Key and address\n * @param {Buffer?} entropy if provided, will use that as single random-source\n */\n\nexport default function createIdentity(entropy) {\n  var privateKey = createPrivateKey(entropy);\n  var wallet = new Wallet(privateKey);\n  var identity = {\n    privateKey: privateKey,\n    // remove trailing '0x04'\n    publicKey: stripHexPrefix(wallet.publicKey).slice(2),\n    address: wallet.address\n  };\n  return identity;\n}","map":{"version":3,"sources":["/Users/salihcemil/Desktop/projects/ecommerce/frontend/node_modules/eth-crypto/dist/es/create-identity.js"],"names":["utils","ethersUtils","Wallet","stripHexPrefix","MIN_ENTROPY_SIZE","keccak256","createPrivateKey","entropy","Buffer","isBuffer","Error","byteLength","outerHex","innerHex","concat","randomBytes","middleHex","_outerHex","createIdentity","privateKey","wallet","identity","publicKey","slice","address"],"mappings":"AAAA,SAASA,KAAK,IAAIC,WAAlB,EAA+BC,MAA/B,QAA6C,QAA7C;AACA,SAASC,cAAT,QAA+B,iBAA/B;AACA,IAAIC,gBAAgB,GAAG,GAAvB;AACA,IAAIC,SAAS,GAAGJ,WAAW,CAACI,SAA5B;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASC,gBAAT,CAA0BC,OAA1B,EAAmC;AACxC,MAAIA,OAAJ,EAAa;AACX,QAAI,CAACC,MAAM,CAACC,QAAP,CAAgBF,OAAhB,CAAL,EAA+B,MAAM,IAAIG,KAAJ,CAAU,0DAAV,CAAN;AAC/B,QAAIF,MAAM,CAACG,UAAP,CAAkBJ,OAAlB,EAA2B,MAA3B,IAAqCH,gBAAzC,EAA2D,MAAM,IAAIM,KAAJ,CAAU,iEAAiEN,gBAA3E,CAAN;AAC3D,QAAIQ,QAAQ,GAAGP,SAAS,CAACE,OAAD,CAAxB;AACA,WAAOK,QAAP;AACD,GALD,MAKO;AACL,QAAIC,QAAQ,GAAGR,SAAS,CAACJ,WAAW,CAACa,MAAZ,CAAmB,CAACb,WAAW,CAACc,WAAZ,CAAwB,EAAxB,CAAD,EAA8Bd,WAAW,CAACc,WAAZ,CAAwB,EAAxB,CAA9B,CAAnB,CAAD,CAAxB;AACA,QAAIC,SAAS,GAAGf,WAAW,CAACa,MAAZ,CAAmB,CAACb,WAAW,CAACa,MAAZ,CAAmB,CAACb,WAAW,CAACc,WAAZ,CAAwB,EAAxB,CAAD,EAA8BF,QAA9B,CAAnB,CAAD,EAA8DZ,WAAW,CAACc,WAAZ,CAAwB,EAAxB,CAA9D,CAAnB,CAAhB;;AAEA,QAAIE,SAAS,GAAGZ,SAAS,CAACW,SAAD,CAAzB;;AAEA,WAAOC,SAAP;AACD;AACF;AACD;AACA;AACA;AACA;AACA;;AAEA,eAAe,SAASC,cAAT,CAAwBX,OAAxB,EAAiC;AAC9C,MAAIY,UAAU,GAAGb,gBAAgB,CAACC,OAAD,CAAjC;AACA,MAAIa,MAAM,GAAG,IAAIlB,MAAJ,CAAWiB,UAAX,CAAb;AACA,MAAIE,QAAQ,GAAG;AACbF,IAAAA,UAAU,EAAEA,UADC;AAEb;AACAG,IAAAA,SAAS,EAAEnB,cAAc,CAACiB,MAAM,CAACE,SAAR,CAAd,CAAiCC,KAAjC,CAAuC,CAAvC,CAHE;AAIbC,IAAAA,OAAO,EAAEJ,MAAM,CAACI;AAJH,GAAf;AAMA,SAAOH,QAAP;AACD","sourcesContent":["import { utils as ethersUtils, Wallet } from 'ethers';\nimport { stripHexPrefix } from 'ethereumjs-util';\nvar MIN_ENTROPY_SIZE = 128;\nvar keccak256 = ethersUtils.keccak256;\n/**\n * create a privateKey from the given entropy or a new one\n * @param  {Buffer} entropy\n * @return {string}\n */\n\nexport function createPrivateKey(entropy) {\n  if (entropy) {\n    if (!Buffer.isBuffer(entropy)) throw new Error('EthCrypto.createPrivateKey(): given entropy is no Buffer');\n    if (Buffer.byteLength(entropy, 'utf8') < MIN_ENTROPY_SIZE) throw new Error('EthCrypto.createPrivateKey(): Entropy-size must be at least ' + MIN_ENTROPY_SIZE);\n    var outerHex = keccak256(entropy);\n    return outerHex;\n  } else {\n    var innerHex = keccak256(ethersUtils.concat([ethersUtils.randomBytes(32), ethersUtils.randomBytes(32)]));\n    var middleHex = ethersUtils.concat([ethersUtils.concat([ethersUtils.randomBytes(32), innerHex]), ethersUtils.randomBytes(32)]);\n\n    var _outerHex = keccak256(middleHex);\n\n    return _outerHex;\n  }\n}\n/**\n * creates a new object with\n * private-, public-Key and address\n * @param {Buffer?} entropy if provided, will use that as single random-source\n */\n\nexport default function createIdentity(entropy) {\n  var privateKey = createPrivateKey(entropy);\n  var wallet = new Wallet(privateKey);\n  var identity = {\n    privateKey: privateKey,\n    // remove trailing '0x04'\n    publicKey: stripHexPrefix(wallet.publicKey).slice(2),\n    address: wallet.address\n  };\n  return identity;\n}"]},"metadata":{},"sourceType":"module"}