{"ast":null,"code":"import { publicKeyConvert } from 'secp256k1';\nimport { pubToAddress, toChecksumAddress, toBuffer } from 'ethereumjs-util';\nimport { hexToUnit8Array, uint8ArrayToHex, addLeading0x } from './util';\nexport function compress(startsWith04) {\n  // add trailing 04 if not done before\n  var testBuffer = Buffer.from(startsWith04, 'hex');\n  if (testBuffer.length === 64) startsWith04 = '04' + startsWith04;\n  return uint8ArrayToHex(publicKeyConvert(hexToUnit8Array(startsWith04), true));\n}\nexport function decompress(startsWith02Or03) {\n  // if already decompressed an not has trailing 04\n  var testBuffer = Buffer.from(startsWith02Or03, 'hex');\n  if (testBuffer.length === 64) startsWith02Or03 = '04' + startsWith02Or03;\n  var decompressed = uint8ArrayToHex(publicKeyConvert(hexToUnit8Array(startsWith02Or03), false)); // remove trailing 04\n\n  decompressed = decompressed.substring(2);\n  return decompressed;\n}\n/**\n * generates the ethereum-adress of the publicKey\n * We create the checksum-adress which is case-sensitive\n * @returns {string} address\n */\n\nexport function toAddress(publicKey) {\n  // normalize key\n  publicKey = decompress(publicKey);\n  var addressBuffer = pubToAddress(toBuffer(addLeading0x(publicKey)));\n  var checkSumAdress = toChecksumAddress(addLeading0x(addressBuffer.toString('hex')));\n  return checkSumAdress;\n}","map":{"version":3,"sources":["/Users/salihcemil/Desktop/projects/ecommerce/node_modules/eth-crypto/dist/es/public-key.js"],"names":["publicKeyConvert","pubToAddress","toChecksumAddress","toBuffer","hexToUnit8Array","uint8ArrayToHex","addLeading0x","compress","startsWith04","testBuffer","Buffer","from","length","decompress","startsWith02Or03","decompressed","substring","toAddress","publicKey","addressBuffer","checkSumAdress","toString"],"mappings":"AAAA,SAASA,gBAAT,QAAiC,WAAjC;AACA,SAASC,YAAT,EAAuBC,iBAAvB,EAA0CC,QAA1C,QAA0D,iBAA1D;AACA,SAASC,eAAT,EAA0BC,eAA1B,EAA2CC,YAA3C,QAA+D,QAA/D;AACA,OAAO,SAASC,QAAT,CAAkBC,YAAlB,EAAgC;AACrC;AACA,MAAIC,UAAU,GAAGC,MAAM,CAACC,IAAP,CAAYH,YAAZ,EAA0B,KAA1B,CAAjB;AACA,MAAIC,UAAU,CAACG,MAAX,KAAsB,EAA1B,EAA8BJ,YAAY,GAAG,OAAOA,YAAtB;AAC9B,SAAOH,eAAe,CAACL,gBAAgB,CAACI,eAAe,CAACI,YAAD,CAAhB,EAAgC,IAAhC,CAAjB,CAAtB;AACD;AACD,OAAO,SAASK,UAAT,CAAoBC,gBAApB,EAAsC;AAC3C;AACA,MAAIL,UAAU,GAAGC,MAAM,CAACC,IAAP,CAAYG,gBAAZ,EAA8B,KAA9B,CAAjB;AACA,MAAIL,UAAU,CAACG,MAAX,KAAsB,EAA1B,EAA8BE,gBAAgB,GAAG,OAAOA,gBAA1B;AAC9B,MAAIC,YAAY,GAAGV,eAAe,CAACL,gBAAgB,CAACI,eAAe,CAACU,gBAAD,CAAhB,EAAoC,KAApC,CAAjB,CAAlC,CAJ2C,CAIqD;;AAEhGC,EAAAA,YAAY,GAAGA,YAAY,CAACC,SAAb,CAAuB,CAAvB,CAAf;AACA,SAAOD,YAAP;AACD;AACD;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASE,SAAT,CAAmBC,SAAnB,EAA8B;AACnC;AACAA,EAAAA,SAAS,GAAGL,UAAU,CAACK,SAAD,CAAtB;AACA,MAAIC,aAAa,GAAGlB,YAAY,CAACE,QAAQ,CAACG,YAAY,CAACY,SAAD,CAAb,CAAT,CAAhC;AACA,MAAIE,cAAc,GAAGlB,iBAAiB,CAACI,YAAY,CAACa,aAAa,CAACE,QAAd,CAAuB,KAAvB,CAAD,CAAb,CAAtC;AACA,SAAOD,cAAP;AACD","sourcesContent":["import { publicKeyConvert } from 'secp256k1';\nimport { pubToAddress, toChecksumAddress, toBuffer } from 'ethereumjs-util';\nimport { hexToUnit8Array, uint8ArrayToHex, addLeading0x } from './util';\nexport function compress(startsWith04) {\n  // add trailing 04 if not done before\n  var testBuffer = Buffer.from(startsWith04, 'hex');\n  if (testBuffer.length === 64) startsWith04 = '04' + startsWith04;\n  return uint8ArrayToHex(publicKeyConvert(hexToUnit8Array(startsWith04), true));\n}\nexport function decompress(startsWith02Or03) {\n  // if already decompressed an not has trailing 04\n  var testBuffer = Buffer.from(startsWith02Or03, 'hex');\n  if (testBuffer.length === 64) startsWith02Or03 = '04' + startsWith02Or03;\n  var decompressed = uint8ArrayToHex(publicKeyConvert(hexToUnit8Array(startsWith02Or03), false)); // remove trailing 04\n\n  decompressed = decompressed.substring(2);\n  return decompressed;\n}\n/**\n * generates the ethereum-adress of the publicKey\n * We create the checksum-adress which is case-sensitive\n * @returns {string} address\n */\n\nexport function toAddress(publicKey) {\n  // normalize key\n  publicKey = decompress(publicKey);\n  var addressBuffer = pubToAddress(toBuffer(addLeading0x(publicKey)));\n  var checkSumAdress = toChecksumAddress(addLeading0x(addressBuffer.toString('hex')));\n  return checkSumAdress;\n}"]},"metadata":{},"sourceType":"module"}