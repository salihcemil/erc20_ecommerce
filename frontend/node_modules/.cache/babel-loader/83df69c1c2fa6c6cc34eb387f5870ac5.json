{"ast":null,"code":"\"use strict\";\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst _secp256k1 = __importStar(require(\"secp256k1\"));\n\nconst random_1 = require(\"../../random\");\n\nconst constants_1 = require(\"../../constants\");\n\nconst helpers_1 = require(\"../../helpers\");\n\nexports.secp256k1 = _secp256k1;\n\nfunction secp256k1Compress(publicKey) {\n  publicKey = helpers_1.sanitizePublicKey(publicKey);\n  return exports.secp256k1.publicKeyConvert(publicKey, true);\n}\n\nexports.secp256k1Compress = secp256k1Compress;\n\nfunction secp256k1Decompress(publicKey) {\n  publicKey = helpers_1.sanitizePublicKey(publicKey);\n  return exports.secp256k1.publicKeyConvert(publicKey, false);\n}\n\nexports.secp256k1Decompress = secp256k1Decompress;\n\nfunction secp256k1GeneratePrivate() {\n  let privateKey = random_1.randomBytes(constants_1.KEY_LENGTH);\n\n  while (!secp256k1VerifyPrivateKey(privateKey)) {\n    privateKey = random_1.randomBytes(constants_1.KEY_LENGTH);\n  }\n\n  return privateKey;\n}\n\nexports.secp256k1GeneratePrivate = secp256k1GeneratePrivate;\n\nfunction secp256k1VerifyPrivateKey(privateKey) {\n  return exports.secp256k1.privateKeyVerify(privateKey);\n}\n\nexports.secp256k1VerifyPrivateKey = secp256k1VerifyPrivateKey;\n\nfunction secp256k1GetPublic(privateKey) {\n  const result = exports.secp256k1.publicKeyCreate(privateKey, false);\n  return result;\n}\n\nexports.secp256k1GetPublic = secp256k1GetPublic;\n\nfunction secp256k1GetPublicCompressed(privateKey) {\n  const result = exports.secp256k1.publicKeyCreate(privateKey, true);\n  return result;\n}\n\nexports.secp256k1GetPublicCompressed = secp256k1GetPublicCompressed;\n\nfunction secp256k1SignatureExport(sig) {\n  return exports.secp256k1.signatureExport(sig);\n}\n\nexports.secp256k1SignatureExport = secp256k1SignatureExport;\n\nfunction secp256k1SignatureImport(sig) {\n  return exports.secp256k1.signatureImport(sig);\n}\n\nexports.secp256k1SignatureImport = secp256k1SignatureImport;\n\nfunction secp256k1Sign(msg, privateKey) {\n  let rsvSig = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const {\n    signature,\n    recovery\n  } = exports.secp256k1.sign(msg, privateKey);\n  return rsvSig ? helpers_1.concatBuffers(signature, helpers_1.exportRecoveryParam(recovery)) : secp256k1SignatureExport(signature);\n}\n\nexports.secp256k1Sign = secp256k1Sign;\n\nfunction secp256k1Recover(sig, msg) {\n  let compressed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  if (helpers_1.isValidDERSignature(sig)) {\n    throw new Error('Cannot recover from DER signatures');\n  }\n\n  const {\n    signature,\n    recovery\n  } = helpers_1.sanitizeRSVSignature(sig);\n  return exports.secp256k1.recover(msg, signature, recovery, compressed);\n}\n\nexports.secp256k1Recover = secp256k1Recover;\n\nfunction secp256k1Verify(sig, msg, publicKey) {\n  if (helpers_1.isValidDERSignature(sig)) {\n    sig = secp256k1SignatureImport(sig);\n  }\n\n  sig = helpers_1.sanitizeRSVSignature(sig).signature;\n  return exports.secp256k1.verify(msg, sig, publicKey);\n}\n\nexports.secp256k1Verify = secp256k1Verify;\n\nfunction secp256k1Derive(publicKey, privateKey, compressed) {\n  let result = exports.secp256k1.ecdhUnsafe(publicKey, privateKey, compressed);\n  return helpers_1.trimLeft(result, constants_1.KEY_LENGTH);\n}\n\nexports.secp256k1Derive = secp256k1Derive;","map":{"version":3,"mappings":";;;;;;;;;;;;;;AAAA;;AAIA;;AACA;;AACA;;AASaA,oBAAwBC,UAAxB;;AAEb,SAAgBC,iBAAhB,CAAkCC,SAAlC,EAAmD;AACjDA,WAAS,GAAGC,4BAAkBD,SAAlB,CAAZ;AACA,SAAOH,kBAAUK,gBAAV,CAA2BF,SAA3B,EAAsC,IAAtC,CAAP;AACD;;AAHDH;;AAKA,SAAgBM,mBAAhB,CAAoCH,SAApC,EAAqD;AACnDA,WAAS,GAAGC,4BAAkBD,SAAlB,CAAZ;AACA,SAAOH,kBAAUK,gBAAV,CAA2BF,SAA3B,EAAsC,KAAtC,CAAP;AACD;;AAHDH;;AAKA,SAAgBO,wBAAhB,GAAwC;AACtC,MAAIC,UAAU,GAAGC,qBAAYC,sBAAZ,CAAjB;;AACA,SAAO,CAACC,yBAAyB,CAACH,UAAD,CAAjC,EAA+C;AAC7CA,cAAU,GAAGC,qBAAYC,sBAAZ,CAAb;AACD;;AACD,SAAOF,UAAP;AACD;;AANDR;;AAQA,SAAgBW,yBAAhB,CAA0CH,UAA1C,EAA4D;AAC1D,SAAOR,kBAAUY,gBAAV,CAA2BJ,UAA3B,CAAP;AACD;;AAFDR;;AAIA,SAAgBa,kBAAhB,CAAmCL,UAAnC,EAAqD;AACnD,QAAMM,MAAM,GAAGd,kBAAUe,eAAV,CAA0BP,UAA1B,EAAsC,KAAtC,CAAf;AACA,SAAOM,MAAP;AACD;;AAHDd;;AAKA,SAAgBgB,4BAAhB,CAA6CR,UAA7C,EAA+D;AAC7D,QAAMM,MAAM,GAAGd,kBAAUe,eAAV,CAA0BP,UAA1B,EAAsC,IAAtC,CAAf;AACA,SAAOM,MAAP;AACD;;AAHDd;;AAKA,SAAgBiB,wBAAhB,CAAyCC,GAAzC,EAAoD;AAClD,SAAOlB,kBAAUmB,eAAV,CAA0BD,GAA1B,CAAP;AACD;;AAFDlB;;AAIA,SAAgBoB,wBAAhB,CAAyCF,GAAzC,EAAoD;AAClD,SAAOlB,kBAAUqB,eAAV,CAA0BH,GAA1B,CAAP;AACD;;AAFDlB;;AAIA,SAAgBsB,aAAhB,CACEC,GADF,EAEEf,UAFF,EAGgB;AAAA,MAAdgB,MAAc,uEAAL,KAAK;AAEd,QAAM;AAAEC,aAAF;AAAaC;AAAb,MAA0B1B,kBAAU2B,IAAV,CAAeJ,GAAf,EAAoBf,UAApB,CAAhC;AACA,SAAOgB,MAAM,GACTpB,wBAAcqB,SAAd,EAAyBrB,8BAAoBsB,QAApB,CAAzB,CADS,GAETT,wBAAwB,CAACQ,SAAD,CAF5B;AAGD;;AATDzB;;AAWA,SAAgB4B,gBAAhB,CAAiCV,GAAjC,EAA8CK,GAA9C,EAA6E;AAAA,MAAlBM,UAAkB,uEAAL,KAAK;;AAC3E,MAAIzB,8BAAoBc,GAApB,CAAJ,EAA8B;AAC5B,UAAM,IAAIY,KAAJ,CAAU,oCAAV,CAAN;AACD;;AACD,QAAM;AAAEL,aAAF;AAAaC;AAAb,MAA0BtB,+BAAqBc,GAArB,CAAhC;AACA,SAAOlB,kBAAU+B,OAAV,CAAkBR,GAAlB,EAAuBE,SAAvB,EAAkCC,QAAlC,EAA4CG,UAA5C,CAAP;AACD;;AAND7B;;AAQA,SAAgBgC,eAAhB,CACEd,GADF,EAEEK,GAFF,EAGEpB,SAHF,EAGmB;AAEjB,MAAIC,8BAAoBc,GAApB,CAAJ,EAA8B;AAC5BA,OAAG,GAAGE,wBAAwB,CAACF,GAAD,CAA9B;AACD;;AACDA,KAAG,GAAGd,+BAAqBc,GAArB,EAA0BO,SAAhC;AACA,SAAOzB,kBAAUiC,MAAV,CAAiBV,GAAjB,EAAsBL,GAAtB,EAA2Bf,SAA3B,CAAP;AACD;;AAVDH;;AAYA,SAAgBkC,eAAhB,CACE/B,SADF,EAEEK,UAFF,EAGEqB,UAHF,EAGsB;AAEpB,MAAIf,MAAM,GAAGd,kBAAUmC,UAAV,CAAqBhC,SAArB,EAAgCK,UAAhC,EAA4CqB,UAA5C,CAAb;AACA,SAAOzB,mBAASU,MAAT,EAAiBJ,sBAAjB,CAAP;AACD;;AAPDV","names":["exports","_secp256k1","secp256k1Compress","publicKey","helpers_1","publicKeyConvert","secp256k1Decompress","secp256k1GeneratePrivate","privateKey","random_1","constants_1","secp256k1VerifyPrivateKey","privateKeyVerify","secp256k1GetPublic","result","publicKeyCreate","secp256k1GetPublicCompressed","secp256k1SignatureExport","sig","signatureExport","secp256k1SignatureImport","signatureImport","secp256k1Sign","msg","rsvSig","signature","recovery","sign","secp256k1Recover","compressed","Error","recover","secp256k1Verify","verify","secp256k1Derive","ecdhUnsafe"],"sources":["../../../../src/lib/secp256k1/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}